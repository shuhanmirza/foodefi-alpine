// Code generated by sqlc. DO NOT EDIT.
// source: event_field_join_event.sql

package db

import (
	"context"
	"time"
)

const listEvents = `-- name: ListEvents :many
SELECT event_fields.id as event_field_id,
       event_id,
       "name",
       "type",
       "value",
       recorder,
       created_at,
       blockchain_id,
       block_number,
       event_name
FROM event_fields
         INNER JOIN events on events.id = event_fields.event_id
ORDER BY event_id LIMIT  $1
OFFSET $2
`

type ListEventsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListEventsRow struct {
	EventFieldID int64     `json:"event_field_id"`
	EventID      int64     `json:"event_id"`
	Name         string    `json:"name"`
	Type         string    `json:"type"`
	Value        string    `json:"value"`
	Recorder     string    `json:"recorder"`
	CreatedAt    time.Time `json:"created_at"`
	BlockchainID int64     `json:"blockchain_id"`
	BlockNumber  int64     `json:"block_number"`
	EventName    string    `json:"event_name"`
}

func (q *Queries) ListEvents(ctx context.Context, arg ListEventsParams) ([]ListEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, listEvents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventsRow{}
	for rows.Next() {
		var i ListEventsRow
		if err := rows.Scan(
			&i.EventFieldID,
			&i.EventID,
			&i.Name,
			&i.Type,
			&i.Value,
			&i.Recorder,
			&i.CreatedAt,
			&i.BlockchainID,
			&i.BlockNumber,
			&i.EventName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByBlockchainId = `-- name: ListEventsByBlockchainId :many
SELECT event_fields.id as event_field_id,
       event_id,
       "name",
       "type",
       "value",
       recorder,
       created_at,
       block_number,
       event_name
FROM event_fields
         INNER JOIN events on events.id = event_fields.event_id
WHERE blockchain_id = $3
ORDER BY event_id LIMIT  $1
OFFSET $2
`

type ListEventsByBlockchainIdParams struct {
	Limit        int32 `json:"limit"`
	Offset       int32 `json:"offset"`
	BlockchainID int64 `json:"blockchain_id"`
}

type ListEventsByBlockchainIdRow struct {
	EventFieldID int64     `json:"event_field_id"`
	EventID      int64     `json:"event_id"`
	Name         string    `json:"name"`
	Type         string    `json:"type"`
	Value        string    `json:"value"`
	Recorder     string    `json:"recorder"`
	CreatedAt    time.Time `json:"created_at"`
	BlockNumber  int64     `json:"block_number"`
	EventName    string    `json:"event_name"`
}

func (q *Queries) ListEventsByBlockchainId(ctx context.Context, arg ListEventsByBlockchainIdParams) ([]ListEventsByBlockchainIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listEventsByBlockchainId, arg.Limit, arg.Offset, arg.BlockchainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventsByBlockchainIdRow{}
	for rows.Next() {
		var i ListEventsByBlockchainIdRow
		if err := rows.Scan(
			&i.EventFieldID,
			&i.EventID,
			&i.Name,
			&i.Type,
			&i.Value,
			&i.Recorder,
			&i.CreatedAt,
			&i.BlockNumber,
			&i.EventName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByBlockchainIdBlockNumberRange = `-- name: ListEventsByBlockchainIdBlockNumberRange :many
SELECT event_fields.id as event_field_id,
       event_id,
       "name",
       "type",
       "value",
       recorder,
       created_at,
       block_number,
       event_name
FROM event_fields
         INNER JOIN events on events.id = event_fields.event_id
WHERE (blockchain_id = $3)
  and (block_number between $4 and $5)
ORDER BY event_id LIMIT  $1
OFFSET $2
`

type ListEventsByBlockchainIdBlockNumberRangeParams struct {
	Limit        int32 `json:"limit"`
	Offset       int32 `json:"offset"`
	BlockchainID int64 `json:"blockchain_id"`
	FromBlock    int64 `json:"from_block"`
	ToBlock      int64 `json:"to_block"`
}

type ListEventsByBlockchainIdBlockNumberRangeRow struct {
	EventFieldID int64     `json:"event_field_id"`
	EventID      int64     `json:"event_id"`
	Name         string    `json:"name"`
	Type         string    `json:"type"`
	Value        string    `json:"value"`
	Recorder     string    `json:"recorder"`
	CreatedAt    time.Time `json:"created_at"`
	BlockNumber  int64     `json:"block_number"`
	EventName    string    `json:"event_name"`
}

func (q *Queries) ListEventsByBlockchainIdBlockNumberRange(ctx context.Context, arg ListEventsByBlockchainIdBlockNumberRangeParams) ([]ListEventsByBlockchainIdBlockNumberRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, listEventsByBlockchainIdBlockNumberRange,
		arg.Limit,
		arg.Offset,
		arg.BlockchainID,
		arg.FromBlock,
		arg.ToBlock,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventsByBlockchainIdBlockNumberRangeRow{}
	for rows.Next() {
		var i ListEventsByBlockchainIdBlockNumberRangeRow
		if err := rows.Scan(
			&i.EventFieldID,
			&i.EventID,
			&i.Name,
			&i.Type,
			&i.Value,
			&i.Recorder,
			&i.CreatedAt,
			&i.BlockNumber,
			&i.EventName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByBlockchainIdEventName = `-- name: ListEventsByBlockchainIdEventName :many
SELECT event_fields.id as event_field_id,
       event_id,
       "name",
       "type",
       "value",
       recorder,
       created_at,
       block_number
FROM event_fields
         INNER JOIN events on events.id = event_fields.event_id
WHERE blockchain_id = $3
  and events.event_name = $4
ORDER BY event_id LIMIT  $1
OFFSET $2
`

type ListEventsByBlockchainIdEventNameParams struct {
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
	BlockchainID int64  `json:"blockchain_id"`
	EventName    string `json:"event_name"`
}

type ListEventsByBlockchainIdEventNameRow struct {
	EventFieldID int64     `json:"event_field_id"`
	EventID      int64     `json:"event_id"`
	Name         string    `json:"name"`
	Type         string    `json:"type"`
	Value        string    `json:"value"`
	Recorder     string    `json:"recorder"`
	CreatedAt    time.Time `json:"created_at"`
	BlockNumber  int64     `json:"block_number"`
}

func (q *Queries) ListEventsByBlockchainIdEventName(ctx context.Context, arg ListEventsByBlockchainIdEventNameParams) ([]ListEventsByBlockchainIdEventNameRow, error) {
	rows, err := q.db.QueryContext(ctx, listEventsByBlockchainIdEventName,
		arg.Limit,
		arg.Offset,
		arg.BlockchainID,
		arg.EventName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventsByBlockchainIdEventNameRow{}
	for rows.Next() {
		var i ListEventsByBlockchainIdEventNameRow
		if err := rows.Scan(
			&i.EventFieldID,
			&i.EventID,
			&i.Name,
			&i.Type,
			&i.Value,
			&i.Recorder,
			&i.CreatedAt,
			&i.BlockNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByBlockchainIdEventNameBlockNumberRange = `-- name: ListEventsByBlockchainIdEventNameBlockNumberRange :many
SELECT event_fields.id as event_field_id,
       event_id,
       "name",
       "type",
       "value",
       recorder,
       created_at,
       block_number
FROM event_fields
         INNER JOIN events on events.id = event_fields.event_id
WHERE (blockchain_id = $3)
  and (block_number between $5 and $6)
  and (event_name = $4)
ORDER BY event_id LIMIT  $1
OFFSET $2
`

type ListEventsByBlockchainIdEventNameBlockNumberRangeParams struct {
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
	BlockchainID int64  `json:"blockchain_id"`
	EventName    string `json:"event_name"`
	FromBlock    int64  `json:"from_block"`
	ToBlock      int64  `json:"to_block"`
}

type ListEventsByBlockchainIdEventNameBlockNumberRangeRow struct {
	EventFieldID int64     `json:"event_field_id"`
	EventID      int64     `json:"event_id"`
	Name         string    `json:"name"`
	Type         string    `json:"type"`
	Value        string    `json:"value"`
	Recorder     string    `json:"recorder"`
	CreatedAt    time.Time `json:"created_at"`
	BlockNumber  int64     `json:"block_number"`
}

func (q *Queries) ListEventsByBlockchainIdEventNameBlockNumberRange(ctx context.Context, arg ListEventsByBlockchainIdEventNameBlockNumberRangeParams) ([]ListEventsByBlockchainIdEventNameBlockNumberRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, listEventsByBlockchainIdEventNameBlockNumberRange,
		arg.Limit,
		arg.Offset,
		arg.BlockchainID,
		arg.EventName,
		arg.FromBlock,
		arg.ToBlock,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventsByBlockchainIdEventNameBlockNumberRangeRow{}
	for rows.Next() {
		var i ListEventsByBlockchainIdEventNameBlockNumberRangeRow
		if err := rows.Scan(
			&i.EventFieldID,
			&i.EventID,
			&i.Name,
			&i.Type,
			&i.Value,
			&i.Recorder,
			&i.CreatedAt,
			&i.BlockNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
